---
title: "dplyr compatibility"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dplyr compatibility}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(dplyr)
knitr::opts_chunk$set(collapse = T, comment = "#>")
```

This vignette is aimed at package authors who need to update their code because of a backward incompatible change to dplyr. We do try and minimise backward incompatible changes as much as possible, but sometimes they are necessary in order to radically simplify existing code, or unlock a lot of potential value in the future.

This vignette starts with some general advice on writing package code that works with multiple version of dplyr, then continues to discuss specific changes in dplyr versions.

## Working with multiple dplyr versions

Ideally, you want to make sure that your package works with both the released version and the development version of dplyr. This is typically a little bit more work, but has two big advantages:

1. It's more convenient for your users, since they're not forced to update
   dplyr if they don't want to)

1. It's easier on CRAN since it doesn't require a massive coordinated release
   of multiple packages.

To make code work with multiple versions of a package, your first tool is the simple if statement:

```{r, results = "hide"}
if (utils::packageVersion("dplyr") > "0.5.0") {
  # code for new version
} else {
  # code for old version
}
```

Always condition on `> current-version`, not `>= next-version` because this will ensure that this branch is also used for the development version of the package. For example, if the current release is version "0.5.0", the development version will be "0.5.0.9000".

Occasionally, you'll run into a situation where the `NAMESPACE` has changed and you need to conditionally import different functions. This typically occurs when functions are moved from one package to another. We try out best to provide automatic fallbacks, but this is not always possible. Often you can work around the problem by avoiding `importFrom` and using `::` instead. Do this where possible:

```{r, eval = FALSE}
if (utils::packageVersion("dplyr") > "0.5.0") {
  dbplyr::build_sql(...)
} else {
  dplyr::build_sql(...)
}
```

This will generate an `R CMD check` NOTE (because the one of the functions will always be missing), but this is ok. Simply explain that you get the note because you have written a wrapper to make sure your code is backward compatible.

Sometimes it's not possible to avoid `importFrom()`. For example you might be importing a generic so that you can define a method for it. In this case, you can take advantage of a little-known feature in the `NAMESPACE` file: you can include `if` statements. 

```{r}
#' @rawNamespace
#' if (utils::packageVersion("dplyr") > "0.5.0") {
#'   importFrom("dbplyr", "build_sql")
#' } else {
#'   importFrom("dplyr", "build_sql")
#' }
```

## dplyr 0.6.0

### Database code moves to dbplyr

Almost all database related code has been moved out of dplyr and into a new package, [dbplyr](http://github.com/hadley/dbplyr/). This makes dplyr simpler, and will make it easier to release fixes for bugs that only affect databases.  If you've implemented a database backend for dplyr, please read the [backend news](https://github.com/hadley/dbplyr/blob/master/NEWS.md#backends) on the backend.

Depending on what generics you use, and what generics you provide methods for you, you may need to write some conditional code. To help make this easier we've written `wrap_dbplyr_obj()` which will write the helper code for you:

```{r}
wrap_dbplyr_obj("build_sql")

wrap_dbplyr_obj("base_agg")
```

Simply copy the results of this function in your package.

These will generate `R CMD check` NOTES, so make sure to tell CRAN that this is to ensure backward compatibility.

### Deprecation of `verb_`

### Deprecation of `mutate_each()` and `summarise_each()`

These functions have been replaced by a more complete family of
functions. This family has suffixes `_if`, `_at` and `_all` and
includes more verbs than just `mutate` `summarise`.

If you need to update your code to the new family, there are two
relevant functions depending on which variables you apply `funs()` to.
If you called `mutate_each()` without supplying a selection of
variables, `funs` is applied to all variables. In this case, you
should update your code to use `mutate_all()` instead:

```{r, eval = FALSE}
mutate_each(starwars, funs(as.character))
mutate_all(starwars, funs(as.character))
```

Note that the new verbs support bare functions as well, so you don't
necessarily need to wrap with `funs()`:

```{r, eval = FALSE}
mutate_all(starwars, as.character)
```


On the other hand, if you supplied a variable selection, you should
use `mutate_at()`. The variable selection should be wrapped with
`vars()`.

```{r, eval = FALSE}
mutate_each(starwars, funs(as.character), height, mass)
mutate_at(starwars, vars(height, mass), as.character)
```

`vars()` supports all the selection helpers that you usually use with
`select()`:

```{r, eval = FALSE}
summarise_at(mtcars, vars(starts_with("d")), mean)
```

Note that intead of a `vars()` selection, you can also supply
character vectors of column names:

```{r, eval = FALSE}
mutate_at(starwars, c("height", "mass"), as.character)
```



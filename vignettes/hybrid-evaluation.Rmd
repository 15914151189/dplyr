<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Hybrid Evaluation}
-->

```{r, echo = FALSE, message = FALSE}
library(ggplot2)
library(dplyr)
knitr::opts_chunk$set(tidy = FALSE)
```

# Hybrid Evaluation

Consider this call to `summarise` : 

```{r, eval = FALSE}
summarise(per_day, flights = sum(flights))
```

One of the way `dplyr` achieves dramatic speedups is that expressions might not 
be evaluated by R, but by alternative code that is faster and uses less memory. 

Conceptually the call to `summarise` above evaluates the expression `sum(flights)`
on each subset of `flights` controlled by the grouping of `per_day`. This involves
creating a new R vector to store the chunk and evaluate the R expression. 

Evaluating the R expression might carry costs that can be avoided, i.e. 
S3 dispatch, ...

`dplyr` recognizes the expression `sum(flights)` as the `sum` function applied 
to a known column of the data, making it possible to handle the dispatch 
early and once, avoid unneeded memory allocations and compute the result faster. 

Hybrid evaluation is able to work on subexpressions. Consider: 

```{r, eval=FALSE}
foo <- function(x) x*x 
summarise(per_day, flights = foo(sum(flights)) )
```

`dplyr` will substitute the subexpressions it knows how to handle and leave the 
rest to standard R evaluation. Instead of evaluating `foo(sum(flights))`, R will 
only have to evaluate `foo(z)` where `z` is the result of the internal evaluation
of `sum(flights)`. 

# Implementation

Hybrid evaluation is designed to be extensible. Before we start registering 
custom hybrid evaluation handlers, we need to understand the system. 

The first building block we need to cover is the `Result` class. 

```{cpp}
namespace dplyr {
    class Result {
    public:
        Result(){}
        virtual ~Result(){} ;
        
        virtual SEXP process( const GroupedDataFrame& gdf) = 0 ;
        
        virtual SEXP process( const FullDataFrame& df ) = 0 ;
        
        virtual SEXP process( const SlicingIndex& index ){
            return R_NilValue ;    
        }
        
    } ;
}
```

The two first methods deal with grouped and ungrouped data frames. 
We will mainly focus on the last method that operates on a `SlicingIndex`. 

`SlicingIndex` is a class that encapsulates indices of a single chunk of a grouped
data frame. 

Hybrid evaluation really just is deriving from the `Result` class. Let's consider 
a simpler version of `sum` that only handles numeric vectors. (The internal version 
is more complete, handles missing values, ...). 

```{cpp}
class Sum : public Result {
  public:
    Sum( NumericVector data_ ): data(data_){}
    
    SEXP process( const SlicingIndex& index ){
      double res = 0.0 ;
      for( int i=0; i<index.size(); i++) res += data[ index[i] ] ;
      return NumericVector::create( res );
    }
    
    virtual SEXP process( const GroupedDataFrame& gdf){
      ...
    }
    virtual SEXP process( const FullDataFrame& df ){
      ...
    }
        
  private:
    NumericVector data ;
} ;
```

## Using Processor

Implementation of `Result` derived classes can be facilitated by the template 
class `Processor`. `Processor` is templated by two template parameters: 
 - the R output type (`REALSXP`, `STRSXP`, ...) 
 - the class you are defining. (This uses the CRTP pattern). 
 
When using `Processor` we only have to supply a `process_chunk` method
that takes a `const SlicingIndex&` as input and returns an object suitable to 
go into a vector of the type controlled by the first template parameter. 

The purpose of the `Processor` template is then to generate the boiler plate 
code for the three `process` methods defined by the `Result` interface. 

A possible `Sum` implementation would then look something like this:

```{cpp}
class Sum : public Processor<REALSXP, Sum> {
  public:
    Sum( NumericVector data_ ): data(data_){}
    
    double process_chunk( const SlicingIndex& index ){
      double res = 0.0 ;
      for( int i=0; i<index.size(); i++) res += data[ index[i] ] ;
      return res;
    }
    
  private:
    NumericVector data ;
}
```

Recognizing genericity here, we might want to make `Sum` a template class
in order to handle more than just numeric vector : 

```{cpp}
template <int RTYPE>
class Sum : public Processor<REALSXP, Sum<RTYPE> > {
  public:
    typedef typename Rcpp::traits::storage_type<RTYPE>::type STORAGE ;
    
    Sum( Vector<RTYPE> data_ ): data(data_){}
    
    STORAGE process_chunk( const SlicingIndex& index ){
      STORAGE res = 0.0 ;
      for( int i=0; i<index.size(); i++) res += data[ index[i] ] ;
      return res;
    }
    
  private:
    Vector<RTYPE> data ;
}
```

Aside from not dealing with missing data and using internal knowledge of the 
`SlicingIndex` class, this implementation of `Sum` is close to the 
internal implementation in `dplyr`. 

## Retrieving hybrid handlers

`dplyr` functions use the `get_result` function to retrieve handlers for 
particular expressions. 





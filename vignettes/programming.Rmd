---
title: "Programming with dplyr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Programming with dplyr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
library(dplyr)

quo <- rlang::quosure
quos <- rlang::dots_quosures
enquo <- rlang::catch_quosure
quo_name <- rlang::quo_text
```

The key dplyr verbs take their arguments by expression rather
than by value. This means that instead of evaluating the arguments working with their values, they capture the expression you typed. This has two main benefits:

*   Operations on data frames can be expressed more succinctly because
    in expressions like `filter(df, x == 1, y == 2, z == 3)` dplyr
    assumes that `x`, `y`, and `z` are variables in df.
    
*   dplyr doesn't need to compute the results as same way as base R.
    For example, for remote tables, dplyr doesn't do any computation
    but instead generates SQL that causes the remote database to do 
    the computation.

Unfortunately these benefits do not come for free. There are two main costs:

*   dplyr code is not referentially transparent. That means that you
    can not replace a value with an intermediate variable. In other
    words, this code:
    
    ```{r, eval = FALSE}
    filter(df, my_var == 1)
    ```
    
    Is not equivalent to this code:
    
    ```{r, eval = FALSE}
    var <- my_var
    filter(df, var == 1)
    ```
    
    This makes it harder to create functions that eliminate
    duplication created by copy and paste.
    
*   dplyr code is ambiguous. Depending on what variables are
    defined where, `filter(df, x == y)` could be equivalent
    to any of:

    ```{r, eval = FALSE}
    df[df$x == df$y, ]
    df[df$x == y, ]
    df[x == df$y, ]
    df[x == y, ]
    ```
    
    This ambiguity makes functions that use dplyr more unpredictable
    than you might desire.

Fortunately, dplyr provides tools to overcome these problems. They require a little more typing, but a small amount of upfront work is worth because you'll save time in the long run.

This vignette has two goals:

*   Show you show you how to use dplyr's __quasiquotation__ and   
    __pronouns__ to write functions that reduce duplication in your 
    code.
    
*   To learn about __quosures__ and underyling __tidyeval__ theory 
    that powers dplyr.

We'll start with a few practical recipes that show you how to reduce duplication in common copy and paste scenarios. Next we'll discuss 

## Programming recipes

The following recipes walk you through the basics of tidyeval, giving you some practical tools for handling duplication in dplyr code. The examples here are somewhat inauthentic because to make them easier to understand we've reduced them down to very simple components, to the point where writing a function almost isn't worth it. Your own data analysis code will be much more complicated, but if you look carefully you should be able to identify similar ideas to the code below.

### Different data sets

If you want to repeat the same operation on different data frames, you can already do it:

```{r, eval = FALSE}
mutate(df1, y = a + x)
mutate(df2, y = a + x)
mutate(df3, y = a + x)
mutate(df4, y = a + x)
```

```{r}
mutate_y <- function(df) {
  mutate(df, y = a + x)
}
```

That's because the data frame argument is referentially transparent. However, this approach has some problems:

```{r}
df1 <- tibble(x = 1:5)
a <- 10
mutate_y(df1)
```

It's better to use the `.data` pronoun to be explicit:

```{r, error = TRUE}
mutate_y <- function(df) {
  mutate(df, y = .data$a + .data$x)
}

mutate_y(df1)
```

This also prevents an `R CMD check` NOTE if you are including this code in a package (you'll need to import `rlang::.data` to fully suppress the note).

### Different expressions

Let's start with a simple case: you want to vary the name of the grouping variable.

```{r}
df <- tibble(
  g1 = c(1, 1, 2, 2, 2),
  g2 = c(1, 2, 1, 2, 1),
  a = sample(5), 
  b = sample(5)
)

df %>%
  group_by(g1) %>%
  summarise(a = mean(a))

df %>%
  group_by(g2) %>%
  summarise(a = mean(a))
```

We can't easily turn this into a function because this doesn't work:

```{r, error = TRUE}
var <- g1
```

Instead we need to capture, or __quote__ this expression. There are two ways to quote in base R: `quote()` and the formula, `~`.

```{r}
quote(g1)
~g1
```

For various reasons, neither of these does quite what we want, so instead we'll use `quo()` (this comes from the rlang package but is also exported by dplyr).

```{r}
var <- quo(g1)
var
```

This looks like a formula (and indeed it is!) but `quo()` does some other important stuff that you'll learn about shortly.

Now that we've captured it, how do we use it with `group_by()`? The naive approach doesn't work because `group_by()` expects its arguments to be names of existing variables:

```{r, error = TRUE}
df %>%
  group_by(var) %>%
  summarise(a = mean(a))
```

In other words, `group_by()` automatically quotes its inputs. But `var` is already quoted, so we need some way to __unquote__ it. In the tidyeval framework, you unquote an expression by putting `!!` in front of it.

```{r}
df %>%
  group_by(!!var) %>%
  summarise(a = mean(a))
```

We are now almost able to write the function:

```{r, error = TRUE}
my_summarise <- function(df, group_by) {
  group_by <- quo(group_by)
  print(group_by)
  
  df %>%
    group_by(!!group_by) %>%
    summarise(a = mean(a))
}

my_summarise(df, g1)
my_summarise(df, g2)
```

I've added a `print()` call to make it obvious what's going wrong here: `quo(group_by)` always returns `~group_by`, but we want it to use the value that the user supplied. That requires a variant called `enquo()`:

```{r}
my_summarise <- function(df, group_by) {
  group_by <- enquo(group_by)

  df %>%
    group_by(!!group_by) %>%
    summarise(a = mean(a))
}

my_summarise(df, g1)
```

(If you're familiar with `quote()` and `substitute()` in base R, `quo()` is equivalent to `quote()` and `enquo()` is equivalent to `substitute()`.)

You might wonder how to extend this to handle multiple grouping variables: we'll come back to that a little later.

### Different input variable

Now let's tackle something a bit more complicated. The code below shows a duplicate `summarise()` statement where we perform three summaries, varying the input variable.

```{r}
summarise(df, mean = mean(a), sum = sum(a), n = n())
summarise(df, mean = mean(a * b), sum = sum(a * b), n = n())
```

Again, to turn this into a function we start by quoting the variable, and unquoting it in the dplyr call:

```{r}
var <- quo(a)
summarise(df, mean = mean(!!var), sum = sum(!!var), n = n())
```

You can also wrap `quo()` around the dplyr call to see what the generated call will look like.

```{r}
quo(summarise(df, 
  mean = mean(!!var),
  sum = sum(!!var),
  n = n()
))
```

This is one of the reason we use `quo()` instead of `~`: `quo()` also does unquoting. This makes it useful for previewing the expression the dplyr will execute.

Now we can turn it into a function, remembering to replace `quo()` with `enquo()`, and check that it works:

```{r}
my_summarise <- function(df, expr) {
  expr <- enquo(expr)
  
  summarise(df, 
    mean = mean(!!expr),
    sum = sum(!!expr),
    n = n()
  )
}
my_summarise(df, a)
my_summarise(df, a * b)
```

### Different input and output variable

The next challenge is to vary the name of the output variables:

```{r}
mutate(df, mean_a = mean(a), sum_a = sum(a))
mutate(df, mean_b = mean(b), sum_b = sum(b))
```

There are two new wrinkles:

* We create the new names by pasting together strings, so
  we need `quo_name()` to convert the input expression to a string.

* `!!mean_name = mean(!!expr)` isn't valid R code, so we need to
  use the helper `:=` provided by rlang.

```{r}
my_mutate <- function(df, expr) {
  expr <- enquo(expr)
  mean_name <- paste0("mean_", quo_name(expr))
  sum_name <- paste0("sum_", quo_name(expr))
  
  mutate(df, 
    !!mean_name := mean(!!expr), 
    !!sum_name := sum(!!expr)
  )
}

my_mutate(df, a)
```

### Capturing multiple variables

It would be nice to extend our first example to accept any number of grouping variables. We need to make three changes:

*   Use `...` in the function argument so our function can accept any number
    of arguments.
    
*   Use `quos()` to capture all the `...` as a list of formulas

*   Use `!!!` instead of `!!` to __splice__ the arguments into the 
    current call site.

```{r}
my_summarise <- function(df, ...) {
  group_by <- quos(...)

  df %>%
    group_by(!!!group_by) %>%
    summarise(a = mean(a))
}

my_summarise(df, g1, g2)
```

`!!!` takes a list of elements and splices them into to the current call:

```{r}
args <- quos(na.rm = TRUE, trim = 0.25)
quo(mean(x, !!! args))
```

Now that you've learned the basics of tidyeval through some practical examples, we'll dive into the theory. This will help you generalise what you've learned to new situations that you haven't seen before.

## Quoting

Quoting is the action of capturing an expression instead of evaluating
it. All expression-based functions quote their arguments and get the R
code as an expression rather than the result of evaluating that
code. If you are an R user, you probably quote expressions on a
regular basis. One of the most important quoting operators in R is the
_formula_. It is famously used for the specification of statistical
models:

```{r}
disp ~ cyl + drat
```

The other quoting operator in base R is `quote()`. It returns a raw
expression rather than a formula:

```{r}
# Computing the value of the expression:
toupper(letters[1:5])

# Capturing the expression:
quote(toupper(letters[1:5]))
```

In practice, the formula is the most important way of quoting an
expression because it captures both the code, and its execution
__environment__. For example, `x` in the following two expressions
should refer to different values:

```{r}
f <- function(x) {
  ~ x
}

x1 <- f(10)
x2 <- f(100)
```

If you print out those formulas, it might look like they're the same. But look carefully at the environment.

```{r}
x1
x2
```

When we evaluate those formulas using `rlang::eval_tidy()`, we see that they yield different values:

```{r, message = FALSE}
library(rlang)

eval_tidy(x1)
eval_tidy(x2)
```

This is an important property of R: a name can refer to different values in different environments.

When an object keep tracks of an environment, it is said
to have an enclosure (functions are another example of such
objects). For this reason we use a special name to refer to one-sided
formulas. We call them __quosures__: one-sided formulas are quotes (they
carry an expression) that bundle their environment. 

Quosures are regular R objects. They can be stored a variables and inspected:

```{r}
var <- ~toupper(letters[1:5])
var

# You can extract its expression:
f_rhs(var)

# Or inspect its enclosure:
f_env(var)
```

In the tidyeval framework, when a function takes an argument by
expression, it gets it in the form of a quosure. This way, it keeps
track of the context where the user typed the expression and knows
where to find user-defined variables mentioned in the quoted
expression. This is how dplyr is able to compute expressions that
refer to a mixture of data frame columns and user-defined variables:

```{r}
user_var <- 1000
mtcars %>% summarise(cyl = mean(cyl) * user_var)
```

However, things get more complicated if you want to store the name of
a column in a variable because dplyr automatically quotes all inputs
related to variables. The solution to this problem is __quasiquotation__,
which is an old term from the LISP community and refers to the ability to 
unquoting part of an expression that is otherwise quoted.

## Quasiquotation

All expression-based functions in the tidyeval framework support
unquoting. Unquoting cancels quotation of parts of an expression. 
There are three types of unquoting:

* unquoting
* unquote splicing
* unquoting names

### Unquoting

The tidyverse provides unquoting operators in a functional form, `UQ()`, and as syntactic-sugar with `!!`.  As shown above, you can use `~` to create a quosure, but `~` does not do quasiquotation, so we'll need to use `quo()` to see how `UQ()` and `!!` work.

```{r}
# Here we capture `letters[1:5]` as an expression:
quo(toupper(letters[1:5]))

# Here we capture the value of `letters[1:5]`
quo(toupper(!!letters[1:5]))
```

It is also possible to unquote other quoted expressions. Unquoting such
symbolic objects provides a powerful a way of manipulating expressions. 

```{r}
var1 <- quo(letters[1:5])
quo(toupper(!!var1))
```

You can safely unquote quosures because they track their environments, and tidyeval functions know how to evaluate them. This allows any numbers of levels quoting and unquoting.

```{r}
my_mutate <- function(x) {
  mtcars %>%
    select(cyl) %>%
    slice(1:4) %>%
    mutate(cyl2 = cyl + (!! x))
}

f <- function(x) quo(x)
expr1 <- f(100)
expr2 <- f(10)

my_mutate(expr1)
my_mutate(expr2)
```

In a way, `quo()` is tidyeval's most fundamental expression-based
function. It captures its expression and returns it without any
modification, post-processing, or evaluation. But all tidyeval
functions like `mutate()` behave like `quosure()` when passed an
expression, which ensures their full programmability.

### Unquote-splicing

The second important operation is unquote-splicing. Its functional
form is `UQS()` and the syntactic shortcut is `!!!`. Like unquoting,
it evaluates part of a captured expression, but if the unquoted object
is a vector, each element of the vector becomes an argument in the
surrounding function call:

```{r}
quosure(list(!!! letters[1:5]))
```

A very useful feature of unquote-splicing is that the vector names
become argument names:

```{r}
quosure(list(!!! list(foo = 1L, bar = quote(baz))))
```

This is of course handy to program with dplyr verbs taking named dots:

```{r}
args <- list(mean = ~mean(cyl), count = ~n())
mtcars %>%
  group_by(am) %>%
  summarise(!!! args)
```

### Setting variable names

There are two main ways of programmatically setting the names of
arguments passed through dots. First you can splice a named vector as
mentioned above: You can also use the definition operator `:=` instead
of `=`. The former supports unquoting on its LHS. The unquoted operand
should evaluate to a string or a symbol:

```{r}
mean_nm <- "mean"
count_nm <- "count"

mtcars %>%
  group_by(am) %>%
  summarise(
    !!mean_nm := mean(cyl),
    !!count_nm := n()
  )
```

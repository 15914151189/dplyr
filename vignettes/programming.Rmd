---
title: "Programming with dplyr"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Non-standard evaluation}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
library(dplyr)

quo <- rlang::quosure
enquo <- rlang::catch_quosure
```

The key dplyr verbs take their arguments by expression rather
than by value. This means that instead of evaluating the arguments working with their values, they capture the expression you typed. This has two main benefits:

*   Operations on data frames can be expressed more succinctly because
    in expressions like `filter(df, x == 1, y == 2, z == 3)` dplyr
    assumes that `x`, `y`, and `z` are variables in df.
    
*   dplyr doesn't need to compute the results as same way as base R.
    For example, for remote tables, dplyr doesn't do any computation
    but instead generates SQL that causes the remote database to do 
    the computation.

Unfortunately these benefits do not come for free. There are two main costs:

*   dplyr code is not referentially transparent. That means that you
    can not replace a value with an intermediate variable. In other
    words, this code:
    
    ```{r, eval = FALSE}
    filter(df, my_var == 1)
    ```
    
    Is not equivalent to this code:
    
    ```{r, eval = FALSE}
    var <- my_var
    filter(df, var == 1)
    ```
    
    This makes it harder to create functions that eliminate
    duplication created by copy and paste.
    
*   dplyr code is ambiguous. Depending on what variables are
    defined where, `filter(df, x == y)` could be equivalent
    to any of:

    ```{r, eval = FALSE}
    df[df$x == df$y, ]
    df[df$x == y, ]
    df[x == df$y, ]
    df[x == y, ]
    ```
    
    This ambiguity makes functions that use dplyr more unpredictable
    than you might desire.

Fortunately, dplyr provides tools to overcome these problems. They require a little more typing, but a small amount of upfront work is worth because you'll save time in the long run.

This vignette has two goals:

*   Show you show you how to use dplyr's __quasiquotation__ and   
    __pronouns__ to write functions that reduce duplication in your 
    code.
    
*   To learn about __quosures__ and underyling __tidyeval__ theory 
    that powers dplyr.

We'll start with a few practical recipes that show you how to reduce duplication in common copy and paste scenarios. Next we'll discuss 

## Programming recipes

The following recipes give some examples of common scenarios where you might currently might be doing a bunch of copy and paste, and want to reduce duplication by writing a function.


The recipes here are slightly inauthentic because we've reduced them down to very simple components, where writing a function almost isn't worth it. Your own data analysis code will be much more complicated, but if you look carefully you should find most examples match one of the simple cases below.

### Different data sets

If you want to repeat the same operation on different data frames, you can already do it:

```{r, eval = FALSE}
mutate(df1, y = a + x)
mutate(df2, y = a + x)
mutate(df3, y = a + x)
mutate(df4, y = a + x)

mutate_y <- function(df) {
  mutate(df, y = a + x)
}
```

That's because the data frame argument is referentially transparent. However, this approach has some problems:

```{r}

```

It's better to use the `.data` pronoun to be explicit:

```{r}
mutate_y <- function(df) {
  mutate(df, y = .data$a + .data$x)
}
```

This also prevents an `R CMD check` NOTE if you are including this code in a package (you'll need to import `rlang::.data` to fully suppress the note).

### Different expressions

Let's step up one level of complexity: now we want to vary the name of a variable used in the expression. Again, this is a fairly contrived example, but it's not uncommon to want to perform the same pipeline of operations but with a different grouping variable.

```{r}
df <- tibble(
  g1 = c(1, 1, 2, 2, 2),
  g2 = c(1, 2, 1, 2, 1),
  a = sample(5), 
  b = sample(5)
)

df %>%
  group_by(g1) %>%
  summarise(a = mean(a))

df %>%
  group_by(g2) %>%
  summarise(a = mean(a))
```

We can't easily turn this into a function because this doesn't work:

```{r, error = TRUE}
var <- g1
```

Instead we need to capture, or __quote__ this expression in another. There are two ways to quote in base R: `quote()` and the formula.

```{r}
quote(g1)
~g1
```

For various reasons, neither of these does quite what we want, so instead we'll use `rlang::quo()` (this is also provided by dplyr so you don't need to load rlang for just this).

```{r}
var <- quo(g1)
var
```

This looks like a formula (and indeed it is!) but `quo()` does some other important stuff that you'll learn about shortly.

Now that we've captured it, how do we use it with `group_by()`? The naive approach doesn't work because `group_by()` expects its arguments to be names of existing variables:

```{r, error = TRUE}
df %>%
  group_by(var) %>%
  summarise(a = mean(a))
```

In other words, `group_by()` automatically quotes its inputs. But we've already quoted `var` so we need some way to __unquote__ it. In the tidyeval framework that dplyr uses, you can unquote an expression by putting `!!` in front of it.

```{r}
df %>%
  group_by(!!var) %>%
  summarise(a = mean(a))
```

We are now almost able to write the function:

```{r, error = TRUE}
my_summarise <- function(df, group_by) {
  group_by <- quo(group_by)
  print(group_by)
  
  df %>%
    group_by(!!group_by) %>%
    summarise(a = mean(a))
}

my_summarise(df, g1)
```

This doesn't work because `quo(group_by)` always returns `~group_by`, but we want it to use the value that the user supplied. That requires variant called `enquo()`:

```{r}
my_summarise <- function(df, group_by) {
  group_by <- enquo(group_by)

  df %>%
    group_by(!!group_by) %>%
    summarise(a = mean(a))
}

my_summarise(df, g1)
```

(If you're familiar with `quote()` and `substitute()` in base R, `quo()` is equivalent to `quote()` and `enquo()` is equivalent to `substitute()`.)

### Different input variable

Now let's tackle something a bit more complicated:

```{r}
summarise(df, mean = mean(a), sum = sum(a), n = n())
summarise(df, mean = mean(a * b), sum = sum(a * b), n = n())
```

It's hard to turn this into a function because we can

We'd like to be able to reduce the duplication here so we can write something like:

```{r, eval = FALSE}
my_summarise(df, a)
my_summarise(df, a * b)
```

```{r}
my_summarise <- function(df, expr) {
  expr <- enquo(expr)
  
  summarise(df, 
    mean = mean(!!expr),
    sum = sum(!!expr),
    n = n()
  )
}
my_summarise(df, a)
my_summarise(df, a * b)
```

You can also wrap quosure around the dplyr call to see what the generate call will look like.

```{r}
expr <- quo(a * b)

quo(summarise(df, 
  mean = mean(!!expr),
  sum = sum(!!expr),
  n = n()
))
```

### Different input and output variable

The next challenge is to vary the name of the output variables:

```{r}
mutate(df, mean_a = mean(a), sum_a = sum(a))
mutate(df, mean_b = mean(b), sum_b = sum(b))
```

The approach is basically the same, but there are two new wrinkles:

* We create the new names by pasting together strings, so
  we need `quo_text()` to get the input expression as a string
  label.

* `!!mean_name = mean(!!expr)` isn't valid R code, so we need to
  use the helper `:=`.

```{r}
my_mutate <- function(df, expr) {
  expr <- enquo(expr)
  mean_name <- paste0("mean_", rlang::quo_text(expr))
  sum_name <- paste0("sum_", rlang::quo_text(expr))
  
  summarise(df, 
    !!mean_name := mean(!!expr), 
    !!sum_name := sum(!!expr)
  )
}

my_mutate(df, a)
```

This code will work if you pass a more complex expression, but will generate "non-syntactic" variable names.

```{r}
my_mutate(df, a * 2)
```

### Different arguments

```{r, eval = FALSE}
summarise_mean(df, mean(a, na.rm = TRUE))
summarise_mean(df, mean(b))
summarise_mean(df, mean(c, trim = 0.2))

summarise_mean <- function(df, var, ...) {
  # Capture unevaluated dots
  dots <- rlang::quosures(...)
  summarise(df, mean(!!var, !!!dots))
}
```

```{r, eval = FALSE}
summaries <- list(~ mean(a), ~ mean(b), ~ mean(c), ~mean(e ^ 2))
summarise(df, !!!sumaries)
```


## Quoting

Quoting is the action of capturing an expression instead of evaluating
it. All expression-based functions quote their arguments and get the R
code as an expression rather than the result of evaluating that
code. If you are an R user, you probably quote expressions on a
regular basis. One of the most important quoting operators in R is the
_formula_. It is famously used for the specification of statistical
models:

```{r}
disp ~ cyl + drat
```

The other quoting operator in base R is `quote()`. It returns a raw
expression rather than a formula:

```{r}
# Computing the value of the expression:
toupper(letters[1:5])

# Capturing the expression:
quote(toupper(letters[1:5]))
```

In practice, the formula is the most important way of quoting an
expression because it knows about the variables defined in the current
context. For example, if you create a formula in the global workspace,
it knows it was created there and that symbols may refer to variables
defined in that context rather than in the context of a function. For
instance, the variable `letters` refers to a standard R object that is
accessible from the global workspace. Typing `~letters` from that
workspace records both the symbol `letters` and the context where it
can be found.

In R and other programming languages, these contexts are called
_environments_. A formula bundles both an expression and an
environment. When an object keep tracks of an environment, it is said
to have an enclosure (functions are another example of such
objects). For this reason we use a special name to refer to one-sided
formulas. We call them _quosures_: one-sided formulas are quotes (they
carry an expression) that bundle an enclosure. Note that unlike
quosures, two-sided formulas bundle not one but two expressions, and
are thus slightly more complex objects. Here is our first quosure:

```{r}
~toupper(letters[1:5])
```

It can be stored in a variable and inspected:

```{r}
var <- ~toupper(letters[1:5])
var

# You can extract its expression:
rlang::f_rhs(var)

# Or inspect its enclosure:
rlang::f_env(var)
```

In the tidyeval framework, when a function takes an argument by
expression, it gets it in the form of a quosure. This way, it keeps
track of the context where the user typed the expression and knows
where to find user-defined variables mentioned in the quoted
expression. This is how dplyr is able to compute expressions that
refer to a mixture of data frame columns and user-defined variables:

```{r}
user_var <- 1000
mtcars %>% summarise(cyl = mean(cyl) * user_var)
```

However, things get more complicated if you want to store the name of
a column in a variable. While dplyr is able to understand variables
referring to _values_, it cannot understand variables referring to
_symbols_. It will just look up the content of the variable and get an
expression. In the following example, the function `mean()` gets the
quoted symbol `disp` as argument. Of course, `mean()` doesn't know
what to do with it since it expects a numeric vector:

```{r}
user_var <- ~disp
mtcars %>% summarise(user_var = mean(user_var) * 1000)
```

The solution to this problem is quasiquotation. This term refers to
the ability of unquoting part of an expression being captured.

## Quasiquotation

### Unquoting

All expression-based functions in the tidyeval framework support
unquoting. Unquoting cancels quotation of parts of an expression. The
tidyverse provides unquoting operators in the functional form, `UQ()`,
and in syntactic form with the double bang operator `!!`. The base R
functions for quoting an expression do not understand unquoting, so we
are going to use the function `quosure()` to illustrate
quasiquotation. `quosure()` takes its argument by expression,
processes the unquoting operators, and returns a quosure.

```{r}
library("rlang")

# Here we capture `letters` as a symbol:
quosure(toupper(letters))

# Here we evaluate `letters` and embed its value in the captured expression:
quosure(toupper(!! letters))
```

In that example we have unquoted a value within `toupper()`. It is
also possible to unquote other quoted expressions. Unquoting such
symbolic objects provides a powerful a way of manipulating expressions
at capture time. From the point of view of the capturing function,
there is no difference between a symbol typed manually or a symbol
unquoted programmatically:

```{r}
var1 <- quote(letters[1:5])
var2 <- quote(letters[11:15])

quosure(toupper(!! var1))

eval_tidy(quosure(toupper(!! var2)))
```

The final touch is that you can safely unquote quosures instead of raw
expressions because tidyeval functions know how to evaluate
quosures. This lets you refer to variables in the current context:

```{r}
my_mutate <- function(x) {
  mtcars %>%
    select(cyl) %>%
    slice(1:5) %>%
    mutate(cyl2 = cyl + (!! x))
}

var <- 100
expr1 <- ~var * 2
expr2 <- ~var / 2

my_mutate(expr1)
my_mutate(expr2)
```

In a way, `quosure()` is tidyeval's most fundamental expression-based
function. It captures its expression and returns it without any
modification, post-processing, or evaluation. But all tidyeval
functions like `mutate()` behave like `quosure()` when passed an
expression, which ensures their full programmability.


### Unquote-splicing

The second important operation is unquote-splicing. Its functional
form is `UQS()` and the syntactic shortcut is `!!!`. Like unquoting,
it evaluates part of a captured expression, but if the unquoted object
is a vector, each element of the vector becomes an argument in the
surrounding function call:

```{r}
quosure(list(!!! letters[1:5]))
```

A very useful feature of unquote-splicing is that the vector names
become argument names:

```{r}
quosure(list(!!! list(foo = 1L, bar = quote(baz))))
```

This is of course handy to program with dplyr verbs taking named dots:

```{r}
args <- list(mean = ~mean(cyl * 20), count = ~n())
mtcars %>%
  group_by(am) %>%
  summarise(!!! args)
```


### Setting variable names

There are two main ways of programmatically setting the names of
arguments passed through dots. First you can splice a named vector as
mentioned above: You can also use the definition operator `:=` instead
of `=`. The former supports unquoting on its LHS. The unquoted operand
should evaluate to a string or a symbol:

```{r}
n <- 10
nms <- c("mean", "count")

summarise(mtcars,
  !! nms[[1]] := mean(mpg),
  !! nms[[2]] := n
)
```

Or equivalently with splicing:

```{r}
dots <- list(~mean(mpg), ~n)
named_dots <- rlang::set_names(dots, nms)

summarise(mtcars, !!! dots)

summarise(mtcars, !!! named_dots)
```

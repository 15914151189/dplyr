<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>dplyr 0.8.0 • dplyr</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="../../tidyverse.css" rel="stylesheet">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../pkgdown.js"></script><link href="../../tidyverse-2.css" rel="stylesheet">
<meta property="og:title" content="dplyr 0.8.0">
<meta property="og:description" content="">
<meta property="og:image" content="http://dplyr.tidyverse.org/logo.png">
<meta name="twitter:card" content="summary">
<meta name="robots" content="noindex">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- google analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-115082821-1"></script><script>
 window.dataLayer = window.dataLayer || [];
 function gtag(){dataLayer.push(arguments);}
 gtag('js', new Date());

 gtag('config', 'UA-115082821-1');
</script>
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div class="navbar-brand-container">
        <a class="navbar-brand" href="../../index.html">dplyr</a>
        <div class="info">
          <span class="partof">part of the <a href="https://tidyverse.org">tidyverse</a></span>
          <span class="version version-danger" data-toggle="tooltip" data-placement="bottom" title="In-development package">0.7.99.9000</span>
        </div>
      </div>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav navbar-right">
<li>
  <a href="../../articles/dplyr.html">Intro</a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/two-table.html">Two-table verbs</a>
    </li>
    <li>
      <a href="../../articles/window-functions.html">Window functions</a>
    </li>
    <li>
      <a href="http://dbplyr.tidyverse.org/articles/dbplyr.html">Databases with dbplyr</a>
    </li>
    <li>
      <a href="../../articles/programming.html">Programming with dplyr</a>
    </li>
    <li>
      <a href="../../articles/compatibility.html">Compatibility</a>
    </li>
  </ul>
</li>
<li>
  <a href="../../news/index.html">News</a>
</li>
        <li>
  <a href="https://github.com/tidyverse/dplyr">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
<form class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="search" class="form-control" name="search-input" id="search-input" placeholder="Search..." aria-label="Search for..." autocomplete="off">
</div>
      </form>
      
    </div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>dplyr 0.8.0</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/tidyverse/dplyr/blob/master/vignettes/future/dplyr_0.8.0.Rmd"><code>vignettes/future/dplyr_0.8.0.Rmd</code></a></small>
      <div class="hidden name"><code>dplyr_0.8.0.Rmd</code></div>

    </div>

    
    
<div id="more-consistent-use-of-factors" class="section level1">
<h1 class="hasAnchor">
<a href="#more-consistent-use-of-factors" class="anchor"></a>More consistent use of factors</h1>
<div id="motivation" class="section level2">
<h2 class="hasAnchor">
<a href="#motivation" class="anchor"></a>Motivation</h2>
<p>The work on making factors used more respectfully originates from the issue 341, which has been waiting for attention for the past four years. <code>#341</code> identified the need to take care of empty groups.</p>
<p>Empty groups can arise from two situations: - when one of the grouping variable in <code><a href="../../reference/group_by.html">group_by()</a></code> is a factor and one of its levels has no data, e.g.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="http://www.rdocumentation.org/packages/tibble/topics/tibble">tibble</a></span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, 
  <span class="dt">f =</span> <span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>))
) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(f)
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt; # Groups:   f [3]</span>
<span class="co">#&gt;       x f    </span>
<span class="co">#&gt;   &lt;int&gt; &lt;fct&gt;</span>
<span class="co">#&gt; 1     1 a    </span>
<span class="co">#&gt; 2     2 b</span></code></pre></div>
<p>The factor <code>f</code> has 3 levels, but only two are present in the data.</p>
<ul>
<li>when all of the data from one group is <code><a href="../../reference/filter.html">filter()</a></code>ed out, e.g.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="http://www.rdocumentation.org/packages/tibble/topics/tibble">tibble</a></span>( <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">f =</span> <span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(f) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/filter.html">filter</a></span>(x <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt; # Groups:   f [3]</span>
<span class="co">#&gt;       x f    </span>
<span class="co">#&gt;   &lt;int&gt; &lt;fct&gt;</span>
<span class="co">#&gt; 1     1 a</span></code></pre></div>
<p>In that case, the grouped data before the filter has one row per level of <code>f</code>, and the filter only keeps the first row so makes 2 empty groups.</p>
</div>
<div id="previous-behaviour" class="section level2">
<h2 class="hasAnchor">
<a href="#previous-behaviour" class="anchor"></a>Previous behaviour</h2>
<p>Older versions of <code>dplyr</code> did not make empty groups, because: - <code><a href="../../reference/group_by.html">group_by()</a></code> was building the grouping metadata only from the rows of the data, i.e. ignoring the conceptual grouping structure. - <code><a href="../../reference/filter.html">filter()</a></code> was making a lazily grouped tibble, recording only the names of grouping variables, without producing the metadata, which was automatically made by a subsequent <code>group_by</code> whenever this was necessary in the future.</p>
</div>
<div id="recusive-slicing-grouping-algorithm" class="section level2">
<h2 class="hasAnchor">
<a href="#recusive-slicing-grouping-algorithm" class="anchor"></a>Recusive slicing grouping algorithm</h2>
<p>A new grouping algorithm, inspired from <code><a href="http://www.rdocumentation.org/packages/tidyr/topics/complete">tidyr::complete</a></code> is used in <code>dplyr</code> 0.8.0 to solve the first issue. The algorithm recursively goes through the grouping variables. When a grouping variable is a factor, the groups are made from its levels. On any other variable (<code>character</code>, <code>integer</code>, …) the groups are made from the unique values.</p>
<p>Let’s have a look at some examples, we’ll use <code><a href="../../reference/tally.html">tally()</a></code> to reveal the grouping structure and counts of groups:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/tibble/topics/tibble">tibble</a></span>(
  <span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>), 
  <span class="dt">f =</span> <span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"a"</span>, <span class="st">"b"</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>))
)
df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(f) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/tally.html">tally</a></span>()
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   f         n</span>
<span class="co">#&gt;   &lt;fct&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 a         2</span>
<span class="co">#&gt; 2 b         2</span>
<span class="co">#&gt; 3 c         0</span></code></pre></div>
<p>In this first example, we group by a factor, so we get as many groups as the number of factors.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(f, x) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/tally.html">tally</a></span>()
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt; # Groups:   f [3]</span>
<span class="co">#&gt;   f         x     n</span>
<span class="co">#&gt;   &lt;fct&gt; &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 a         1     2</span>
<span class="co">#&gt; 2 b         2     2</span>
<span class="co">#&gt; 3 c        NA     0</span></code></pre></div>
<p>Here we group by the factor <code>f</code> and the numeric vector <code>x</code>. Again we get 3 groups, because for the levels “a” and “b” of <code>f</code>, there is only one value of <code>x</code>. The third group, associated with the level “c” sets the value of <code>x</code> to <code>NA</code> out of thin air. We call this a <em>sentinel NA</em> and we might make it obvious later that this is not the same as if we had a missing value in the data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(x, f) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/tally.html">tally</a></span>()
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt; # Groups:   x [2]</span>
<span class="co">#&gt;       x f         n</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;fct&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     1 a         2</span>
<span class="co">#&gt; 2     1 b         0</span>
<span class="co">#&gt; 3     1 c         0</span>
<span class="co">#&gt; 4     2 a         0</span>
<span class="co">#&gt; # ... with 2 more rows</span></code></pre></div>
<p>In this case, we get more groups, and consequently more empty groups, because of the recursive slicing, first we find 2 unique values for the variable <code>x</code> (1 and 2), then we group by the factor <code>f</code> and therefore get 3 groups (because 3 levels) for each unique value of <code>x</code>.</p>
</div>
<div id="propagation-of-the-grouping-structure" class="section level2">
<h2 class="hasAnchor">
<a href="#propagation-of-the-grouping-structure" class="anchor"></a>Propagation of the grouping structure</h2>
<p><code><a href="../../reference/filter.html">filter()</a></code> has been reworked to respect the grouping stucture and gains the <code>.preserve</code> argument to control which groups to keep.</p>
<p>When <code>.preserve</code> is set to <code>TRUE</code> (the default) the groups of the filtered tibble are the same as the groups of the original tibble.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(x, f) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/filter.html">filter</a></span>(x <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/tally.html">tally</a></span>()
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt; # Groups:   x [2]</span>
<span class="co">#&gt;       x f         n</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;fct&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     1 a         2</span>
<span class="co">#&gt; 2     1 b         0</span>
<span class="co">#&gt; 3     1 c         0</span>
<span class="co">#&gt; 4     2 a         0</span>
<span class="co">#&gt; # ... with 2 more rows</span>

df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(f, x) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/filter.html">filter</a></span>(x <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/tally.html">tally</a></span>()
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt; # Groups:   f [3]</span>
<span class="co">#&gt;   f         x     n</span>
<span class="co">#&gt;   &lt;fct&gt; &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 a         1     2</span>
<span class="co">#&gt; 2 b         2     0</span>
<span class="co">#&gt; 3 c        NA     0</span></code></pre></div>
<p>When <code>.preserve</code> is set to <code>FALSE</code> the grouping structure is recalculated after the filtering.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(x, f) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/filter.html">filter</a></span>(x <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">.preserve =</span> <span class="ot">FALSE</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/tally.html">tally</a></span>()
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt; # Groups:   x [1]</span>
<span class="co">#&gt;       x f         n</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;fct&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     1 a         2</span>
<span class="co">#&gt; 2     1 b         0</span>
<span class="co">#&gt; 3     1 c         0</span></code></pre></div>
<p>Here we only get 3 groups, from the 3 levels of <code>f</code> within the unique value of <code>x</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(f, x) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/filter.html">filter</a></span>(x <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">.preserve =</span> <span class="ot">FALSE</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/tally.html">tally</a></span>()
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt; # Groups:   f [3]</span>
<span class="co">#&gt;   f         x     n</span>
<span class="co">#&gt;   &lt;fct&gt; &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 a         1     2</span>
<span class="co">#&gt; 2 b        NA     0</span>
<span class="co">#&gt; 3 c        NA     0</span></code></pre></div>
<p>In that case, we get 3 groups, but the values of <code>x</code> are slightly different, i.e. the value of <code>x</code> associated with the level “b” in the empty group is a sentinel NA.</p>
</div>
</div>
<div id="tidy-grouping-structure" class="section level1">
<h1 class="hasAnchor">
<a href="#tidy-grouping-structure" class="anchor"></a>Tidy grouping structure</h1>
<p>Previous versions of <code>dplyr</code> used a messy collection of attributes in the “grouped_df” class, which did not make it easy to reason about. <code>dplyr</code> 0.8.0 structures all the grouping information in a tibble with <code>n+1</code> columns (where <code>n</code> is the number of grouping variables) in the “groups” attribute.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(f, x) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">attr</span>(<span class="st">"groups"</span>)
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   f         x .rows    </span>
<span class="co">#&gt;   &lt;fct&gt; &lt;dbl&gt; &lt;list&gt;   </span>
<span class="co">#&gt; 1 a         1 &lt;int [2]&gt;</span>
<span class="co">#&gt; 2 b         2 &lt;int [2]&gt;</span>
<span class="co">#&gt; 3 c        NA &lt;int [0]&gt;</span></code></pre></div>
<p>The first columns identify the data for each of the group, one row per group. This is equivalent to the “labels” attribute used in previous versions of <code>dplyr</code>.</p>
<p>The last column, always called <code>.rows</code> is a list column of integer vectors (possibly of length 0 for empty groups) identifying the indices of all the rows in the data that belong to the group. This is equivalent to the “indices” attribute used in previous versions.</p>
<p>This grouping stucture tibble (maybe a gribble) can be retrieved by accessing the <code>groups</code> attribute, or preferably by using the <code><a href="../../reference/group_data.html">group_data()</a></code> generic, which has methods for ungrouped and row wise data too.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../../reference/group_data.html">group_data</a></span>(df)
<span class="co">#&gt; # A tibble: 1 x 1</span>
<span class="co">#&gt;   .rows    </span>
<span class="co">#&gt;   &lt;list&gt;   </span>
<span class="co">#&gt; 1 &lt;int [4]&gt;</span>
<span class="kw"><a href="../../reference/group_data.html">group_data</a></span>(<span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(df, f))
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   f     .rows    </span>
<span class="co">#&gt;   &lt;fct&gt; &lt;list&gt;   </span>
<span class="co">#&gt; 1 a     &lt;int [2]&gt;</span>
<span class="co">#&gt; 2 b     &lt;int [2]&gt;</span>
<span class="co">#&gt; 3 c     &lt;int [0]&gt;</span>
<span class="kw"><a href="../../reference/group_data.html">group_data</a></span>(<span class="kw"><a href="../../reference/rowwise.html">rowwise</a></span>(df))
<span class="co">#&gt; # A tibble: 4 x 1</span>
<span class="co">#&gt;   .rows    </span>
<span class="co">#&gt;   &lt;list&gt;   </span>
<span class="co">#&gt; 1 &lt;int [1]&gt;</span>
<span class="co">#&gt; 2 &lt;int [1]&gt;</span>
<span class="co">#&gt; 3 &lt;int [1]&gt;</span>
<span class="co">#&gt; 4 &lt;int [1]&gt;</span></code></pre></div>
<p>Similarly, the indices themselves can be retrieved using <code><a href="../../reference/group_data.html">group_rows()</a></code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../../reference/group_data.html">group_rows</a></span>(df)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1 2 3 4</span>
<span class="kw"><a href="../../reference/group_data.html">group_rows</a></span>(<span class="kw"><a href="../../reference/group_by.html">group_by</a></span>(df, f))
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 2 4</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; integer(0)</span>
<span class="kw"><a href="../../reference/group_data.html">group_rows</a></span>(<span class="kw"><a href="../../reference/rowwise.html">rowwise</a></span>(df))
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] 4</span></code></pre></div>
<p>Having a consistent representation of the grouping structure makes it easier to reason about, and might open opportunities to discuss alternative ways of grouping</p>
</div>
<div id="hybrid-evaluation-cleanup" class="section level1">
<h1 class="hasAnchor">
<a href="#hybrid-evaluation-cleanup" class="anchor"></a>Hybrid evaluation cleanup</h1>
<p><strong>pending</strong></p>
<p>The initial goal for hybrid evaluation was to bypass potentially expensive R evaluation, and replace it with more efficient C++ code. Unfortunately, there are situations where hybrid evaluation creates problems.</p>
<p>There are two forms of hybrid evaluation in dplyr at the moment: full hybrid evaluation and hybrid folding.</p>
<div id="full-hybrid-evaluation" class="section level2">
<h2 class="hasAnchor">
<a href="#full-hybrid-evaluation" class="anchor"></a>Full hybrid evaluation</h2>
<p>When the entire (summarise or mutate) expression can be handled, e.g. in <code>group_by(...) %&gt;% summarise(m = mean(x))</code> the <code>mean</code> hybrid handler takes care of everything, i.e. calculate the mean of x for each group and structure that into a numeric vector.</p>
<p>This does not need to allocate memory for each subset of <code>x</code> or the result of <code>mean(x)</code>. In addition, because it is dispatched internally, it does not need to pay the expensive price of S3 dispatch of the <code>mean</code> generic function from <code>base::</code>.</p>
<p>This is where hybrid evaluation really makes a difference. Currently this is driven by a set of C++ classes inheriting from the virtual class <code>Result</code>, which is used for summary functions (such as <code>mean</code>) and window functions (such as <code>lead</code>).</p>
<p>The proposal here is to rebase hybrid handlers on two virtual class (maybe templates) instead of one: - <code>template &lt;int RTYPE&gt; Window&lt;RTYPE&gt;</code> would give a vector of type RTYPE of the right size. - <code>template &lt;int RTYPE&gt; Summary&lt;RTYPE&gt;</code> would summarise into of value of the right type.</p>
<p><code>mutate</code> and <code>summarise</code> would recognise expressions that are hybridable, and use the information to allocate the result then iterate through the groups to fill the result.</p>
<p>This needs careful refactoring. We believe that this will make the code much simpler, with the consequence that it will be easier to write new hybrid handlers, i.e. we can imagine something like <code>x == 2</code> to be handled hybridly in <code>filter</code> by using a class deriving from <code>Window&lt;LGLSXP&gt;</code>.</p>
</div>
<div id="hybrid-folding" class="section level2">
<h2 class="hasAnchor">
<a href="#hybrid-folding" class="anchor"></a>Hybrid folding</h2>
<p>This is where hybrid evaluation creates problems, because it is sometimes too eager, and generally cannot faithfully mimic standard R evaulation. The original idea was to handle <em>parts</em> of the expression using the hybrid handlers, e.g. in the expression <code>%&gt;% group_by(...) %&gt;% summarise(m = 1 + mean(x))</code> we would handle <code>mean(x)</code> with the hybrid handler for <code>mean</code>, fold that into the expression and then fall back to r evaluation once we can no longer hybrid evaluate anything.</p>
<p>Folding cannot be done once and for all groups, it is performed (including going through the expressions) for each group which has a price, we have to end with an R evaluation anyway, and then after that we still have no idea of what the result will be, so we collect and coerce the result with care.</p>
<p>This has been the source of most of the “surprises” and also comes at a huge cost in terms of code complexity, and therefore maintainability.</p>
<p>The proposal here is to totally abandon hybrid folding and replace it with an approach based on regular R evaluation. Expressions would be evaluated in an environment in which the names of the columns are mapped to their subsets in the current group, and where functions such as <code><a href="../../reference/n.html">n()</a></code> and <code><a href="../../reference/ranking.html">row_number()</a></code> produce the desired result.</p>
<p>Letting go of hybrid folding and making it easier to implement full hybrid handlers will make hybrid evaluation simpler, more robust and less surprising.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#more-consistent-use-of-factors">More consistent use of factors</a><ul class="nav nav-pills nav-stacked">
<li><a href="#motivation">Motivation</a></li>
      <li><a href="#previous-behaviour">Previous behaviour</a></li>
      <li><a href="#recusive-slicing-grouping-algorithm">Recusive slicing grouping algorithm</a></li>
      <li><a href="#propagation-of-the-grouping-structure">Propagation of the grouping structure</a></li>
      </ul>
</li>
      <li><a href="#tidy-grouping-structure">Tidy grouping structure</a></li>
      <li>
<a href="#hybrid-evaluation-cleanup">Hybrid evaluation cleanup</a><ul class="nav nav-pills nav-stacked">
<li><a href="#full-hybrid-evaluation">Full hybrid evaluation</a></li>
      <li><a href="#hybrid-folding">Hybrid folding</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="tidyverse">
  <p>dplyr is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href="https://tidyverse.org">tidyverse.org</a>.</p>
</div>

<div class="author">
  <p>
    Developed by <a href="http://hadley.nz">Hadley Wickham</a>, Romain François, Lionel Henry, Kirill Müller, <a href="https://www.rstudio.com"><img src="https://tidyverse.org/rstudio-logo.svg" alt="RStudio" height="24"></a>.
    Site built by <a href="https://pkgdown.r-lib.org">pkgdown</a>.
  </p>
</div>
      </footer>
</div>

  
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><script>
  docsearch({
    
    
    apiKey: '1270c4079b26a138795263974bbf302d',
    indexName: 'tidyverse',
    inputSelector: 'input#search-input.form-control',
    transformData: function(hits) {
      return hits.map(function (hit) {
        hit.url = updateHitURL(hit);
        return hit;
      });
    }
  });
</script>
</body>
</html>

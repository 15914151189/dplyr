#' Operate on a selection of variables.
#'
#' The variants suffixed with `_if`, `_at` or `_all` apply an
#' expression (sometimes several) to all variables within a specified
#' subset. This subset can contain all variables (`_all` variants), a
#' [vars()] selection (`_at` variants), or variables selected with a
#' predicate (`_if` variants).
#'
#' The families with scoped variants are:
#'
#' * [mutate()] and [summarise()]. See [summarise_all()].
#' * [filter()]. See [filter_all()].
#'
#' @param .tbl A `tbl` object.
#' @param .funs List of function calls generated by
#'   [funs()], or a character vector of function names, or
#'   simply a function (only for local sources).
#' @param .vars A list of columns generated by [vars()],
#'   or a character vector of column names, or a numeric vector of column
#'   positions.
#' @param .predicate A predicate function to be applied to the columns
#'   or a logical vector. The columns for which `.predicate` is
#'   or returns `TRUE` will be summarised or mutated.
#' @param ... Additional arguments for the function calls in
#'   `.funs`. These are evaluated only once.
#' @name scoped
NULL


#' Select variables.
#'
#' This helper is intended to provide equivalent semantics to
#' [select()]. It is used for instance in scoped summarising and
#' mutating verbs ([mutate_at()] and [summarise_at()]).
#'
#' Note that verbs accepting a `vars()` specification also accept an
#' [integerish][rlang::is_integerish] vector of positions or a
#' character vector of column names.
#'
#' @param ... Variables to include/exclude in mutate/summarise. You
#'   can use same specifications as in [select()]. If
#'   missing, defaults to all non-grouping variables.
#' @seealso [funs()], [all_vars()] and [any_vars()] for other quoting
#'   functions that you can use with scoped verbs.
#' @export
vars <- function(...) {
  quos(...)
}

#' Apply predicate to all variables.
#'
#' These quoting functions signal to scoped filtering verbs
#' (e.g. [filter_if()] or [filter_all()]) that a predicate expression
#' should be applied to all relevant variables. The `all_vars()`
#' variant takes the intersection of the predicate expressions with
#' `&` while the `any_vars()` variant takes the union with `|`.
#'
#' @param expr A predicate expression. This variable supports
#'   [unquoting][rlang::quasiquotation] and will be evaluated in the
#'   context of the data frame. It should return a logical vector.
#' @seealso [funs()] and [vars()] for other quoting functions that you
#'   can use with scoped verbs.
#' @export
all_vars <- function(expr) {
  struct(enquo(expr), class = c("all_vars", "quosure", "formula"))
}
#' @rdname all_vars
#' @export
any_vars <- function(expr) {
  struct(enquo(expr), class = c("any_vars", "quosure", "formula"))
}
#' @export
print.all_vars <- function(x, ...) {
  cat("<predicate intersection>\n")
  NextMethod()
}
#' @export
print.any_vars <- function(x, ...) {
  cat("<predicate union>\n")
  NextMethod()
}


# Requires tbl_vars() method
tbl_at_syms <- function(tbl, vars) {
  tibble_vars <- tbl_vars(tbl, group_vars = FALSE)

  if (is_character(vars)) {
    syms <- syms(vars)
  } else if (is_integerish(vars)) {
    syms <- syms(tibble_vars[vars])
  } else if (is_quosures(vars)) {
    syms <- syms(select_vars(tibble_vars, !!! vars))
    # Forward `vars` names to `syms`. Account for caveat that `syms`
    # might be smaller than `vars`.
    if (any(have_name(vars))) {
      vars <- syms
    } else {
      names(vars) <- NULL
    }
  } else {
    abort("`.cols` should be a character/numeric vector or a `vars()` object")
  }

  set_names(syms, names(vars))
}

# Requires tbl_vars(), `[[`() and length() methods
tbl_if_syms <- function(.tbl, .p, ...) {
  vars <- tbl_vars(.tbl, group_vars = FALSE)

  if (is_logical(.p)) {
    stopifnot(length(.p) == length(vars))
    return(syms(vars[.p]))
  }

  if (inherits(.tbl, "tbl_lazy")) {
    inform("Applying predicate on the first 100 rows")
    .tbl <- collect(.tbl, n = 100)
  }

  n <- length(.tbl)
  selected <- lgl_len(n)
  for (i in seq_len(n)) {
    selected[[i]] <- .p(.tbl[[i]], ...)
  }

  vars <- vars[selected]
  syms(vars)
}

apply_syms <- function(funs, syms, tbl) {
  stopifnot(is_fun_list(funs))

  out <- vector("list", length(syms) * length(funs))
  dim(out) <- c(length(syms), length(funs))
  for (i in seq_along(syms)) {
    for (j in seq_along(funs)) {
      var_sym <- sym(syms[[i]])
      out[[i, j]] <- expr_substitute(funs[[j]], quote(.), var_sym)
    }
  }
  dim(out) <- NULL

  if (length(funs) == 1 && !attr(funs, "have_name")) {
    names(out) <- map_chr(syms, as_string)
  } else if (length(syms) == 1 && !is_named(syms)) {
    names(out) <- names(funs)
  } else {
    syms_names <- map_chr(syms, as_string)
    grid <- expand.grid(var = syms_names, call = names(funs))
    names(out) <- paste(grid$var, grid$call, sep = "_")
  }

  out
}

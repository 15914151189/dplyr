% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colwise-mutate.R
\name{mutate_all}
\alias{mutate_all}
\title{Mutate multiple columns}
\usage{
mutate_all(.tbl, .funs, ...)
}
\arguments{
\item{.tbl}{A \code{tbl} object.}

\item{.funs}{List of function calls generated by \code{\link[=funs]{funs()}}, or a
character vector of function names, or simply a function.

Bare formulas are passed to \code{\link[rlang:as_function]{rlang::as_function()}} to create
purrr-style lambda functions. Note that these lambda prevent
hybrid evaluation from happening and it is thus more efficient to
supply functions like \code{mean()} directly rather than in a
lambda-formula.}

\item{...}{Additional arguments for the function calls in
\code{.funs}. These are evaluated only once, with \link[rlang:tidy-dots]{tidy dots} support.}
}
\value{
A data frame. By default, the newly created columns have the shortest
names needed to uniquely identify the output. To force inclusion of a name,
even when not needed, name the input (see examples for details).
}
\description{
These verbs are \link{scoped} variants of \code{\link[=mutate]{mutate()}} and \code{\link[=transmute]{transmute()}}.
They mutate a selection of variables.
}
\section{Grouping variables}{


If applied on a grouped tibble, these operations normally apply to
only to the non-grouping variables.
\itemize{
\item \code{mutate_if()}, \code{mutate_all()}, \code{transmute_if()}, and
\code{transmute_all()} issue a message when the selection includes
grouping variables to make it explicit that they are ignored.

In the case of \code{_all} variants, you can silence the message by
using a variable selection that explicitly ignores the grouping
variables. Here is call equivalent to \code{mutate_all()} that does
not output messages:\preformatted{data \%>\% mutate_at(vars(-group_cols()), my_operation)
}

This makes the selection more explicit in your code.
\item \code{mutate_at()} and \code{transmute_at()} throw an error when the
selection includes grouping variables.
}
}

\examples{
iris <- as_tibble(iris)

# The scoped variants of mutate() make it easy to apply the same
# transformation to multiple variables. There are three variants:
# * _all affects every variable
# * _at affects variables selected with a character vector or vars()
# * _if affects variables selected with a predicate function:

# All variants can be passed functions and additional arguments,
# purrr-style. The _at() variants directly support strings. Here
# we'll divide two variables by 100:
starwars \%>\% mutate_at(c("height", "mass"), `/`, 100)

# You can also supply selection helpers to _at() functions but you have
# to quote them with vars():
iris \%>\% mutate_at(vars(matches("Sepal")), log)

# The _if() variants apply a predicate function (a function that
# returns TRUE or FALSE) to determine the relevant subset of
# columns. Here we divide all the numeric columns by 100:
starwars \%>\% mutate_if(is.numeric, `/`, 100)

# mutate_if() is particularly useful for transforming variables from
# one type to another
iris \%>\% mutate_if(is.factor, as.character)
iris \%>\% mutate_if(is.double, as.integer)


# If you want to apply multiple transformations, pass a list of
# functions. When there are multiple functions, they create new
# variables instead of modifying the variables in place:
iris \%>\% mutate_if(is.numeric, list(`/`, `*`), 100)

# Note how the new variables include the function name, in order to
# keep things distinct. Passing purrr-style lambdas often creates
# better default names:
iris \%>\% mutate_if(is.numeric, list(~ . / 100, mul = ~ . * 100))

# When that's not good enough, you can also supply the names explicitly:
iris \%>\% mutate_if(is.numeric, list(div = `/`, mul = `*`), 100)

# When there's only one function in the list, it modifies existing
# variables in place. Give it a name to create new variables instead:
iris \%>\% mutate_if(is.numeric, list(`/`), 100)
iris \%>\% mutate_if(is.numeric, list(div = `/`), 100)
}
\seealso{
\link[=scoped]{The other scoped verbs}, \code{\link[=vars]{vars()}}, \code{\link[=funs]{funs()}}
}
